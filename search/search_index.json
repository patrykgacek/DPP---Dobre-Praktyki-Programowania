{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TGiS-BFS Documentation Welcome to the TGiS-BFS project documentation. Overview Application of the BFS algorithm to analyze the spread of information in social networks Python-based application designed to analyze the spread of information within social networks using the Breadth-First Search (BFS) algorithm. This tool allows users to visualize social network connections and the spread of information from a given starting node. Features Graph Creation : Create social network graphs from a list of nodes and edges. Random Community Generation : Generate random community graphs with specified parameters. BFS Algorithm : Perform BFS traversal to analyze the spread of information. Visualization : Visualize social network connections and the spread of information using Matplotlib. Debug Mode : Enable debug mode to print detailed information during the BFS traversal. Installation To install the required dependencies, it is recommended to use a virtual environment. Follow the steps below: Clone the repository: git clone https://github.com/patrykgacek/TGiS-BFS. git cd TGiS-BFS Create and activate a virtual environment: python -m venv venv source venv/bin/activate # On Windows use `venv\\Scripts\\activate` Install the dependencies: pip install -r requirements.txt Usage Running the Main Script To run the main script and visualize the social network and information spread, use the following command: python src/main.py Running Tests To run the unit tests, use the following command: python -m unittest discover -s tests Example Code Here is an example of how to use the BfsCommunityGraph class: from models.bfs_community_graph import BfsCommunityGraph people = [ \"Patryk\", \"Kasia\", \"Kajetan\", \"Ania\", \"Artur\", \"Karolina\", \"Tomek\", \"Klaudia\", \"Krzysiek\", \"Asia\", ] connections = [ (\"Patryk\", \"Kasia\"), (\"Patryk\", \"Kajetan\"), (\"Patryk\", \"Ania\"), (\"Patryk\", \"Artur\"), (\"Kasia\", \"Karolina\"), (\"Kasia\", \"Tomek\"), (\"Kajetan\", \"Klaudia\"), (\"Kajetan\", \"Krzysiek\"), (\"Ania\", \"Asia\"), (\"Ania\", \"Krzysiek\"), (\"Artur\", \"Karolina\"), (\"Artur\", \"Tomek\"), (\"Karolina\", \"Klaudia\"), (\"Klaudia\", \"Krzysiek\"), (\"Krzysiek\", \"Asia\"), ] graph = BfsCommunityGraph(debug=True) graph.make_graph(people, connections) # creates a graph from a list of people and their connections order = graph.run() # runs the BFS algorithm graph.draw_compare() # draws a comparison of the original connections and the spread of information. graph.draw_compare() # draws the graph of all social connections provided by the user. graph.draw_spread() # draws the graph of the resulted information spread. Instead of using make_graph , you can use random_community to generate a sample network, where you can adjust the number of people and the probabilities of connections between them: graph.random_community(5, 0.4) This will create a network with 5 individuals, where the probability of a connection between any two individuals is 40% (0.4).","title":"Home"},{"location":"#tgis-bfs-documentation","text":"Welcome to the TGiS-BFS project documentation.","title":"TGiS-BFS Documentation"},{"location":"#overview","text":"Application of the BFS algorithm to analyze the spread of information in social networks Python-based application designed to analyze the spread of information within social networks using the Breadth-First Search (BFS) algorithm. This tool allows users to visualize social network connections and the spread of information from a given starting node.","title":"Overview"},{"location":"#features","text":"Graph Creation : Create social network graphs from a list of nodes and edges. Random Community Generation : Generate random community graphs with specified parameters. BFS Algorithm : Perform BFS traversal to analyze the spread of information. Visualization : Visualize social network connections and the spread of information using Matplotlib. Debug Mode : Enable debug mode to print detailed information during the BFS traversal.","title":"Features"},{"location":"#installation","text":"To install the required dependencies, it is recommended to use a virtual environment. Follow the steps below: Clone the repository: git clone https://github.com/patrykgacek/TGiS-BFS. git cd TGiS-BFS Create and activate a virtual environment: python -m venv venv source venv/bin/activate # On Windows use `venv\\Scripts\\activate` Install the dependencies: pip install -r requirements.txt","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#running-the-main-script","text":"To run the main script and visualize the social network and information spread, use the following command: python src/main.py","title":"Running the Main Script"},{"location":"#running-tests","text":"To run the unit tests, use the following command: python -m unittest discover -s tests","title":"Running Tests"},{"location":"#example-code","text":"Here is an example of how to use the BfsCommunityGraph class: from models.bfs_community_graph import BfsCommunityGraph people = [ \"Patryk\", \"Kasia\", \"Kajetan\", \"Ania\", \"Artur\", \"Karolina\", \"Tomek\", \"Klaudia\", \"Krzysiek\", \"Asia\", ] connections = [ (\"Patryk\", \"Kasia\"), (\"Patryk\", \"Kajetan\"), (\"Patryk\", \"Ania\"), (\"Patryk\", \"Artur\"), (\"Kasia\", \"Karolina\"), (\"Kasia\", \"Tomek\"), (\"Kajetan\", \"Klaudia\"), (\"Kajetan\", \"Krzysiek\"), (\"Ania\", \"Asia\"), (\"Ania\", \"Krzysiek\"), (\"Artur\", \"Karolina\"), (\"Artur\", \"Tomek\"), (\"Karolina\", \"Klaudia\"), (\"Klaudia\", \"Krzysiek\"), (\"Krzysiek\", \"Asia\"), ] graph = BfsCommunityGraph(debug=True) graph.make_graph(people, connections) # creates a graph from a list of people and their connections order = graph.run() # runs the BFS algorithm graph.draw_compare() # draws a comparison of the original connections and the spread of information. graph.draw_compare() # draws the graph of all social connections provided by the user. graph.draw_spread() # draws the graph of the resulted information spread. Instead of using make_graph , you can use random_community to generate a sample network, where you can adjust the number of people and the probabilities of connections between them: graph.random_community(5, 0.4) This will create a network with 5 individuals, where the probability of a connection between any two individuals is 40% (0.4).","title":"Example Code"},{"location":"auto_bfs_community_graph/","text":"Automatically generated with mkdocstrings src.models.bfs_community_graph.BfsCommunityGraph Impletentation of the BFS algorithm for analyzing information spread in social networks. :param graph: Graph object representing the social network :param start_node: The node to start the BFS traversal from :param debug: Flag for printing debug information during the BFS algorithm Source code in src/models/bfs_community_graph.py class BfsCommunityGraph: \"\"\" Impletentation of the BFS algorithm for analyzing information spread in social networks. :param graph: Graph object representing the social network :param start_node: The node to start the BFS traversal from :param debug: Flag for printing debug information during the BFS algorithm \"\"\" def __init__(self, graph: Graph = None, start_node: str = None, debug: bool = False): self.graph: Graph = graph # Social network graph self.start_node: str = start_node # Start node for BFS algorithm self.spread_graph: DiGraph = None # Spread information graph self.bfs_deep: int = 0 # deepest level of the result graph self.bfs_order: List[str] = [] # Order of visited nodes self.bfs_debug: bool = debug # Debug flag for BFS algorithm def __str__(self) -> str: \"\"\" Return the string representation of the graph. :return: String representation of the graph \"\"\" gstr = ( f\"Graph Nodes: {self.graph.nodes() if self.graph else '-'}\\n\" f\"Graph Edges: {self.graph.edges() if self.graph else '-'}\\n\" f\"Deep: {self.bfs_deep}\\n\" f\"Spread order: {self.bfs_order}\\n\" f\"Start node: {self.start_node}\\n\" f\"Is Connected: {nx.is_connected(self.graph) if self.graph else '-'}\\n\" f\"Result graph nodes: {self.spread_graph.nodes() if self.spread_graph else '-'}\\n\" f\"Result graph edges: {self.spread_graph.edges() if self.spread_graph else '-'}\\n\" ) return gstr def is_valid(self) -> bool: \"\"\" Check if the graph is valid for BFS algorithm. :return: True if the graph is valid, False otherwise \"\"\" valid = True if not self.graph: print(\"Error: Graph is not set.\") valid = False if valid and not isinstance(self.start_node, str): print(\"Error: Start node should be a string.\") valid = False if valid and not all(isinstance(node, str) for node in self.graph.nodes): print(\"Error: Nodes should be strings.\") valid = False if valid and self.start_node not in self.graph.nodes: print(\"Error: Start node is not in the graph.\") valid = False if not valid: print( \"Please resolve the above issues before analyzing information spread in social networks.\" ) return valid def __print_log(self, message: str) -> None: \"\"\" Print log message if debug flag is set. :param message: Log message to print \"\"\" if self.bfs_debug: print(message) def __bfs(self) -> List[str]: \"\"\" Perform BFS traversal starting from the given node. :return: List of nodes in BFS order \"\"\" self.spread_graph = nx.DiGraph() visited = set() queue = deque([(self.start_node, 0)]) bfs_order = [] visited.add(self.start_node) self.spread_graph.add_node(self.start_node) while queue: self.__print_log(f\"Queue: {queue}\") node, level = queue.popleft() self.__print_log(f\"Visiting {node} at level {level}\") bfs_order.append({node: level}) self.__print_log(f\"Neighbors of {node}: {list(self.graph.neighbors(node))}\") for neighbor in self.graph.neighbors(node): if neighbor not in visited: self.__print_log(f\"Adding {neighbor} to the queue\") next_level = level + 1 queue.append((neighbor, next_level)) self.bfs_deep = max(self.bfs_deep, next_level) visited.add(neighbor) self.spread_graph.add_node(neighbor) self.spread_graph.add_edge(node, neighbor) else: self.__print_log(f\"Skipping {neighbor}\") self.__print_log(f\"BFS end. Order: {bfs_order}\") self.bfs_order = bfs_order return bfs_order def __clean_results(self) -> None: \"\"\" Clean the results of the BFS algorithm. \"\"\" self.bfs_order = [] self.start_node = None self.spread_graph = None def __calc_node_colors(self, cmap: plt.cm) -> plt.cm: \"\"\" Return a colormap for coloring nodes based on their levels. :param cmap: Colormap object :return: Calculated colormap for coloring nodes \"\"\" levels = [list(node.values())[0] for node in self.bfs_order] norm = plt.Normalize(levels[0], levels[-1]) return cmap(norm(levels)) def run(self, start_node: str = None) -> List[Dict[str, int]]: \"\"\" Run the BFS algorithm and return the results. :param start_node: The node to start the BFS traversal from :return: List of nodes in BFS order \"\"\" if start_node: self.start_node = start_node else: self.start_node = list(self.graph.nodes)[0] if self.graph else None if not self.is_valid(): return {} self.__bfs() return self.bfs_order def make_graph(self, nodes: List[str], edges: List[Tuple[str, str]]) -> None: \"\"\" Create a graph from the given nodes and edges. :param nodes: List of nodes in the graph :param edges: List of edges in the graph \"\"\" self.__clean_results() self.graph = nx.Graph() self.graph.add_nodes_from(nodes) self.graph.add_edges_from(edges) def random_community(self, num_nodes: int, edge_prob: float, seed: int = None) -> None: \"\"\" Generate a random community graph with string nodes. :param num_nodes: Number of nodes in the graph :param edge_prob: Probability of an edge between nodes :param seed: Random seed for reproducibility \"\"\" self.__clean_results() self.graph = nx.erdos_renyi_graph(num_nodes, edge_prob, seed) labels = {i: f\"Person_{i}\" for i in range(num_nodes)} self.graph = nx.relabel_nodes(self.graph, labels) def draw_connections( self, figsize: Tuple[int, int] = (10, 8), node_size: int = 2000, node_color: str = \"lightblue\", edge_color: str = \"gray\", ) -> None: \"\"\" Draw the connections of the graph. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param node_color: Color of the nodes :param edge_color: Color of the edges \"\"\" if not self.graph: print(\"Error: Graph is not set. Load some data first.\") return pos = nx.spring_layout(self.graph) plt.figure(figsize=figsize) nx.draw_networkx_nodes(self.graph, pos, node_size=node_size, node_color=node_color) nx.draw_networkx_labels(self.graph, pos) nx.draw_networkx_edges(self.graph, pos, edge_color=edge_color, arrows=False) plt.title(CONNECTIONS_TITLE) plt.show() def draw_spread( self, figsize: Tuple[int, int] = (10, 8), node_size: int = 2000, edge_color: str = \"gray\", cmap: plt.cm = plt.cm.summer, alpha: float = 0.5, arrow_style: str = \"-|>\", arrow_size: int = 20, ) -> None: \"\"\" Draw the spread of information from the start node. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param edge_color: Color of the edges :param cmap: Colormap for coloring nodes based on their levels :param alpha: Transparency of the nodes \"\"\" if not self.spread_graph: print(\"Error: Spread graph is not set. Use BfsCommunityGraph.run() method first.\") return plt.figure(figsize=figsize) pos = nx.spring_layout(self.spread_graph) node_colors = self.__calc_node_colors(cmap) nx.draw_networkx_nodes( self.spread_graph, pos, node_size=node_size, alpha=alpha, node_color=node_colors, ) nx.draw_networkx_labels( self.spread_graph, pos, ) nx.draw_networkx_edges( self.spread_graph, pos, edge_color=edge_color, arrows=True, arrowstyle=arrow_style, node_size=node_size, arrowsize=arrow_size, ) plt.title(f\"{SPREAD_TITLE} from {self.start_node}\") plt.show() def draw_compare( self, figsize: Tuple[int, int] = (20, 8), node_size: int = 2000, node_color: str = \"lightblue\", edge_color: str = \"gray\", spread_cmap: plt.cm = plt.cm.summer, spread_arrow_size: int = 20, spread_alpha: float = 0.5, spread_arrow_style: str = \"-|>\", ) -> None: \"\"\" Draw the original graph and the spread graph side by side. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param node_color: Color of the nodes :param edge_color: Color of the edges :param spread_cmap: Colormap for coloring nodes based on their levels :param spread_arrow_size: Size of the arrows :param spread_alpha: Transparency of the nodes :param spread_arrow_style: Style of the arrows \"\"\" if not self.graph or not self.spread_graph: print(\"Error: Compares is not available. Load some data and run BFS first.\") return _, axes = plt.subplots(1, 2, figsize=figsize) pos = nx.spring_layout(self.graph) nx.draw_networkx_nodes( self.graph, pos, ax=axes[0], node_size=node_size, node_color=node_color ) nx.draw_networkx_labels(self.graph, pos, ax=axes[0]) nx.draw_networkx_edges(self.graph, pos, ax=axes[0], edge_color=edge_color, arrows=False) axes[0].set_title(CONNECTIONS_TITLE) pos = nx.spring_layout(self.spread_graph) node_colors = self.__calc_node_colors(spread_cmap) nx.draw_networkx_nodes( self.spread_graph, pos, ax=axes[1], node_size=node_size, alpha=spread_alpha, node_color=node_colors, ) nx.draw_networkx_labels(self.spread_graph, pos, ax=axes[1]) nx.draw_networkx_edges( self.spread_graph, pos, ax=axes[1], edge_color=edge_color, arrows=True, arrowstyle=spread_arrow_style, node_size=node_size, arrowsize=spread_arrow_size, ) axes[1].set_title(f\"{SPREAD_TITLE} from {self.start_node}\") plt.show() __bfs() Perform BFS traversal starting from the given node. :return: List of nodes in BFS order Source code in src/models/bfs_community_graph.py def __bfs(self) -> List[str]: \"\"\" Perform BFS traversal starting from the given node. :return: List of nodes in BFS order \"\"\" self.spread_graph = nx.DiGraph() visited = set() queue = deque([(self.start_node, 0)]) bfs_order = [] visited.add(self.start_node) self.spread_graph.add_node(self.start_node) while queue: self.__print_log(f\"Queue: {queue}\") node, level = queue.popleft() self.__print_log(f\"Visiting {node} at level {level}\") bfs_order.append({node: level}) self.__print_log(f\"Neighbors of {node}: {list(self.graph.neighbors(node))}\") for neighbor in self.graph.neighbors(node): if neighbor not in visited: self.__print_log(f\"Adding {neighbor} to the queue\") next_level = level + 1 queue.append((neighbor, next_level)) self.bfs_deep = max(self.bfs_deep, next_level) visited.add(neighbor) self.spread_graph.add_node(neighbor) self.spread_graph.add_edge(node, neighbor) else: self.__print_log(f\"Skipping {neighbor}\") self.__print_log(f\"BFS end. Order: {bfs_order}\") self.bfs_order = bfs_order return bfs_order __calc_node_colors(cmap) Return a colormap for coloring nodes based on their levels. :param cmap: Colormap object :return: Calculated colormap for coloring nodes Source code in src/models/bfs_community_graph.py def __calc_node_colors(self, cmap: plt.cm) -> plt.cm: \"\"\" Return a colormap for coloring nodes based on their levels. :param cmap: Colormap object :return: Calculated colormap for coloring nodes \"\"\" levels = [list(node.values())[0] for node in self.bfs_order] norm = plt.Normalize(levels[0], levels[-1]) return cmap(norm(levels)) __clean_results() Clean the results of the BFS algorithm. Source code in src/models/bfs_community_graph.py def __clean_results(self) -> None: \"\"\" Clean the results of the BFS algorithm. \"\"\" self.bfs_order = [] self.start_node = None self.spread_graph = None __print_log(message) Print log message if debug flag is set. :param message: Log message to print Source code in src/models/bfs_community_graph.py def __print_log(self, message: str) -> None: \"\"\" Print log message if debug flag is set. :param message: Log message to print \"\"\" if self.bfs_debug: print(message) __str__() Return the string representation of the graph. :return: String representation of the graph Source code in src/models/bfs_community_graph.py def __str__(self) -> str: \"\"\" Return the string representation of the graph. :return: String representation of the graph \"\"\" gstr = ( f\"Graph Nodes: {self.graph.nodes() if self.graph else '-'}\\n\" f\"Graph Edges: {self.graph.edges() if self.graph else '-'}\\n\" f\"Deep: {self.bfs_deep}\\n\" f\"Spread order: {self.bfs_order}\\n\" f\"Start node: {self.start_node}\\n\" f\"Is Connected: {nx.is_connected(self.graph) if self.graph else '-'}\\n\" f\"Result graph nodes: {self.spread_graph.nodes() if self.spread_graph else '-'}\\n\" f\"Result graph edges: {self.spread_graph.edges() if self.spread_graph else '-'}\\n\" ) return gstr draw_compare(figsize=(20, 8), node_size=2000, node_color='lightblue', edge_color='gray', spread_cmap=plt.cm.summer, spread_arrow_size=20, spread_alpha=0.5, spread_arrow_style='-|>') Draw the original graph and the spread graph side by side. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param node_color: Color of the nodes :param edge_color: Color of the edges :param spread_cmap: Colormap for coloring nodes based on their levels :param spread_arrow_size: Size of the arrows :param spread_alpha: Transparency of the nodes :param spread_arrow_style: Style of the arrows Source code in src/models/bfs_community_graph.py def draw_compare( self, figsize: Tuple[int, int] = (20, 8), node_size: int = 2000, node_color: str = \"lightblue\", edge_color: str = \"gray\", spread_cmap: plt.cm = plt.cm.summer, spread_arrow_size: int = 20, spread_alpha: float = 0.5, spread_arrow_style: str = \"-|>\", ) -> None: \"\"\" Draw the original graph and the spread graph side by side. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param node_color: Color of the nodes :param edge_color: Color of the edges :param spread_cmap: Colormap for coloring nodes based on their levels :param spread_arrow_size: Size of the arrows :param spread_alpha: Transparency of the nodes :param spread_arrow_style: Style of the arrows \"\"\" if not self.graph or not self.spread_graph: print(\"Error: Compares is not available. Load some data and run BFS first.\") return _, axes = plt.subplots(1, 2, figsize=figsize) pos = nx.spring_layout(self.graph) nx.draw_networkx_nodes( self.graph, pos, ax=axes[0], node_size=node_size, node_color=node_color ) nx.draw_networkx_labels(self.graph, pos, ax=axes[0]) nx.draw_networkx_edges(self.graph, pos, ax=axes[0], edge_color=edge_color, arrows=False) axes[0].set_title(CONNECTIONS_TITLE) pos = nx.spring_layout(self.spread_graph) node_colors = self.__calc_node_colors(spread_cmap) nx.draw_networkx_nodes( self.spread_graph, pos, ax=axes[1], node_size=node_size, alpha=spread_alpha, node_color=node_colors, ) nx.draw_networkx_labels(self.spread_graph, pos, ax=axes[1]) nx.draw_networkx_edges( self.spread_graph, pos, ax=axes[1], edge_color=edge_color, arrows=True, arrowstyle=spread_arrow_style, node_size=node_size, arrowsize=spread_arrow_size, ) axes[1].set_title(f\"{SPREAD_TITLE} from {self.start_node}\") plt.show() draw_connections(figsize=(10, 8), node_size=2000, node_color='lightblue', edge_color='gray') Draw the connections of the graph. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param node_color: Color of the nodes :param edge_color: Color of the edges Source code in src/models/bfs_community_graph.py def draw_connections( self, figsize: Tuple[int, int] = (10, 8), node_size: int = 2000, node_color: str = \"lightblue\", edge_color: str = \"gray\", ) -> None: \"\"\" Draw the connections of the graph. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param node_color: Color of the nodes :param edge_color: Color of the edges \"\"\" if not self.graph: print(\"Error: Graph is not set. Load some data first.\") return pos = nx.spring_layout(self.graph) plt.figure(figsize=figsize) nx.draw_networkx_nodes(self.graph, pos, node_size=node_size, node_color=node_color) nx.draw_networkx_labels(self.graph, pos) nx.draw_networkx_edges(self.graph, pos, edge_color=edge_color, arrows=False) plt.title(CONNECTIONS_TITLE) plt.show() draw_spread(figsize=(10, 8), node_size=2000, edge_color='gray', cmap=plt.cm.summer, alpha=0.5, arrow_style='-|>', arrow_size=20) Draw the spread of information from the start node. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param edge_color: Color of the edges :param cmap: Colormap for coloring nodes based on their levels :param alpha: Transparency of the nodes Source code in src/models/bfs_community_graph.py def draw_spread( self, figsize: Tuple[int, int] = (10, 8), node_size: int = 2000, edge_color: str = \"gray\", cmap: plt.cm = plt.cm.summer, alpha: float = 0.5, arrow_style: str = \"-|>\", arrow_size: int = 20, ) -> None: \"\"\" Draw the spread of information from the start node. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param edge_color: Color of the edges :param cmap: Colormap for coloring nodes based on their levels :param alpha: Transparency of the nodes \"\"\" if not self.spread_graph: print(\"Error: Spread graph is not set. Use BfsCommunityGraph.run() method first.\") return plt.figure(figsize=figsize) pos = nx.spring_layout(self.spread_graph) node_colors = self.__calc_node_colors(cmap) nx.draw_networkx_nodes( self.spread_graph, pos, node_size=node_size, alpha=alpha, node_color=node_colors, ) nx.draw_networkx_labels( self.spread_graph, pos, ) nx.draw_networkx_edges( self.spread_graph, pos, edge_color=edge_color, arrows=True, arrowstyle=arrow_style, node_size=node_size, arrowsize=arrow_size, ) plt.title(f\"{SPREAD_TITLE} from {self.start_node}\") plt.show() is_valid() Check if the graph is valid for BFS algorithm. :return: True if the graph is valid, False otherwise Source code in src/models/bfs_community_graph.py def is_valid(self) -> bool: \"\"\" Check if the graph is valid for BFS algorithm. :return: True if the graph is valid, False otherwise \"\"\" valid = True if not self.graph: print(\"Error: Graph is not set.\") valid = False if valid and not isinstance(self.start_node, str): print(\"Error: Start node should be a string.\") valid = False if valid and not all(isinstance(node, str) for node in self.graph.nodes): print(\"Error: Nodes should be strings.\") valid = False if valid and self.start_node not in self.graph.nodes: print(\"Error: Start node is not in the graph.\") valid = False if not valid: print( \"Please resolve the above issues before analyzing information spread in social networks.\" ) return valid make_graph(nodes, edges) Create a graph from the given nodes and edges. :param nodes: List of nodes in the graph :param edges: List of edges in the graph Source code in src/models/bfs_community_graph.py def make_graph(self, nodes: List[str], edges: List[Tuple[str, str]]) -> None: \"\"\" Create a graph from the given nodes and edges. :param nodes: List of nodes in the graph :param edges: List of edges in the graph \"\"\" self.__clean_results() self.graph = nx.Graph() self.graph.add_nodes_from(nodes) self.graph.add_edges_from(edges) random_community(num_nodes, edge_prob, seed=None) Generate a random community graph with string nodes. :param num_nodes: Number of nodes in the graph :param edge_prob: Probability of an edge between nodes :param seed: Random seed for reproducibility Source code in src/models/bfs_community_graph.py def random_community(self, num_nodes: int, edge_prob: float, seed: int = None) -> None: \"\"\" Generate a random community graph with string nodes. :param num_nodes: Number of nodes in the graph :param edge_prob: Probability of an edge between nodes :param seed: Random seed for reproducibility \"\"\" self.__clean_results() self.graph = nx.erdos_renyi_graph(num_nodes, edge_prob, seed) labels = {i: f\"Person_{i}\" for i in range(num_nodes)} self.graph = nx.relabel_nodes(self.graph, labels) run(start_node=None) Run the BFS algorithm and return the results. :param start_node: The node to start the BFS traversal from :return: List of nodes in BFS order Source code in src/models/bfs_community_graph.py def run(self, start_node: str = None) -> List[Dict[str, int]]: \"\"\" Run the BFS algorithm and return the results. :param start_node: The node to start the BFS traversal from :return: List of nodes in BFS order \"\"\" if start_node: self.start_node = start_node else: self.start_node = list(self.graph.nodes)[0] if self.graph else None if not self.is_valid(): return {} self.__bfs() return self.bfs_order","title":"DocString (BfsCommunityGraph)"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph","text":"Impletentation of the BFS algorithm for analyzing information spread in social networks. :param graph: Graph object representing the social network :param start_node: The node to start the BFS traversal from :param debug: Flag for printing debug information during the BFS algorithm Source code in src/models/bfs_community_graph.py class BfsCommunityGraph: \"\"\" Impletentation of the BFS algorithm for analyzing information spread in social networks. :param graph: Graph object representing the social network :param start_node: The node to start the BFS traversal from :param debug: Flag for printing debug information during the BFS algorithm \"\"\" def __init__(self, graph: Graph = None, start_node: str = None, debug: bool = False): self.graph: Graph = graph # Social network graph self.start_node: str = start_node # Start node for BFS algorithm self.spread_graph: DiGraph = None # Spread information graph self.bfs_deep: int = 0 # deepest level of the result graph self.bfs_order: List[str] = [] # Order of visited nodes self.bfs_debug: bool = debug # Debug flag for BFS algorithm def __str__(self) -> str: \"\"\" Return the string representation of the graph. :return: String representation of the graph \"\"\" gstr = ( f\"Graph Nodes: {self.graph.nodes() if self.graph else '-'}\\n\" f\"Graph Edges: {self.graph.edges() if self.graph else '-'}\\n\" f\"Deep: {self.bfs_deep}\\n\" f\"Spread order: {self.bfs_order}\\n\" f\"Start node: {self.start_node}\\n\" f\"Is Connected: {nx.is_connected(self.graph) if self.graph else '-'}\\n\" f\"Result graph nodes: {self.spread_graph.nodes() if self.spread_graph else '-'}\\n\" f\"Result graph edges: {self.spread_graph.edges() if self.spread_graph else '-'}\\n\" ) return gstr def is_valid(self) -> bool: \"\"\" Check if the graph is valid for BFS algorithm. :return: True if the graph is valid, False otherwise \"\"\" valid = True if not self.graph: print(\"Error: Graph is not set.\") valid = False if valid and not isinstance(self.start_node, str): print(\"Error: Start node should be a string.\") valid = False if valid and not all(isinstance(node, str) for node in self.graph.nodes): print(\"Error: Nodes should be strings.\") valid = False if valid and self.start_node not in self.graph.nodes: print(\"Error: Start node is not in the graph.\") valid = False if not valid: print( \"Please resolve the above issues before analyzing information spread in social networks.\" ) return valid def __print_log(self, message: str) -> None: \"\"\" Print log message if debug flag is set. :param message: Log message to print \"\"\" if self.bfs_debug: print(message) def __bfs(self) -> List[str]: \"\"\" Perform BFS traversal starting from the given node. :return: List of nodes in BFS order \"\"\" self.spread_graph = nx.DiGraph() visited = set() queue = deque([(self.start_node, 0)]) bfs_order = [] visited.add(self.start_node) self.spread_graph.add_node(self.start_node) while queue: self.__print_log(f\"Queue: {queue}\") node, level = queue.popleft() self.__print_log(f\"Visiting {node} at level {level}\") bfs_order.append({node: level}) self.__print_log(f\"Neighbors of {node}: {list(self.graph.neighbors(node))}\") for neighbor in self.graph.neighbors(node): if neighbor not in visited: self.__print_log(f\"Adding {neighbor} to the queue\") next_level = level + 1 queue.append((neighbor, next_level)) self.bfs_deep = max(self.bfs_deep, next_level) visited.add(neighbor) self.spread_graph.add_node(neighbor) self.spread_graph.add_edge(node, neighbor) else: self.__print_log(f\"Skipping {neighbor}\") self.__print_log(f\"BFS end. Order: {bfs_order}\") self.bfs_order = bfs_order return bfs_order def __clean_results(self) -> None: \"\"\" Clean the results of the BFS algorithm. \"\"\" self.bfs_order = [] self.start_node = None self.spread_graph = None def __calc_node_colors(self, cmap: plt.cm) -> plt.cm: \"\"\" Return a colormap for coloring nodes based on their levels. :param cmap: Colormap object :return: Calculated colormap for coloring nodes \"\"\" levels = [list(node.values())[0] for node in self.bfs_order] norm = plt.Normalize(levels[0], levels[-1]) return cmap(norm(levels)) def run(self, start_node: str = None) -> List[Dict[str, int]]: \"\"\" Run the BFS algorithm and return the results. :param start_node: The node to start the BFS traversal from :return: List of nodes in BFS order \"\"\" if start_node: self.start_node = start_node else: self.start_node = list(self.graph.nodes)[0] if self.graph else None if not self.is_valid(): return {} self.__bfs() return self.bfs_order def make_graph(self, nodes: List[str], edges: List[Tuple[str, str]]) -> None: \"\"\" Create a graph from the given nodes and edges. :param nodes: List of nodes in the graph :param edges: List of edges in the graph \"\"\" self.__clean_results() self.graph = nx.Graph() self.graph.add_nodes_from(nodes) self.graph.add_edges_from(edges) def random_community(self, num_nodes: int, edge_prob: float, seed: int = None) -> None: \"\"\" Generate a random community graph with string nodes. :param num_nodes: Number of nodes in the graph :param edge_prob: Probability of an edge between nodes :param seed: Random seed for reproducibility \"\"\" self.__clean_results() self.graph = nx.erdos_renyi_graph(num_nodes, edge_prob, seed) labels = {i: f\"Person_{i}\" for i in range(num_nodes)} self.graph = nx.relabel_nodes(self.graph, labels) def draw_connections( self, figsize: Tuple[int, int] = (10, 8), node_size: int = 2000, node_color: str = \"lightblue\", edge_color: str = \"gray\", ) -> None: \"\"\" Draw the connections of the graph. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param node_color: Color of the nodes :param edge_color: Color of the edges \"\"\" if not self.graph: print(\"Error: Graph is not set. Load some data first.\") return pos = nx.spring_layout(self.graph) plt.figure(figsize=figsize) nx.draw_networkx_nodes(self.graph, pos, node_size=node_size, node_color=node_color) nx.draw_networkx_labels(self.graph, pos) nx.draw_networkx_edges(self.graph, pos, edge_color=edge_color, arrows=False) plt.title(CONNECTIONS_TITLE) plt.show() def draw_spread( self, figsize: Tuple[int, int] = (10, 8), node_size: int = 2000, edge_color: str = \"gray\", cmap: plt.cm = plt.cm.summer, alpha: float = 0.5, arrow_style: str = \"-|>\", arrow_size: int = 20, ) -> None: \"\"\" Draw the spread of information from the start node. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param edge_color: Color of the edges :param cmap: Colormap for coloring nodes based on their levels :param alpha: Transparency of the nodes \"\"\" if not self.spread_graph: print(\"Error: Spread graph is not set. Use BfsCommunityGraph.run() method first.\") return plt.figure(figsize=figsize) pos = nx.spring_layout(self.spread_graph) node_colors = self.__calc_node_colors(cmap) nx.draw_networkx_nodes( self.spread_graph, pos, node_size=node_size, alpha=alpha, node_color=node_colors, ) nx.draw_networkx_labels( self.spread_graph, pos, ) nx.draw_networkx_edges( self.spread_graph, pos, edge_color=edge_color, arrows=True, arrowstyle=arrow_style, node_size=node_size, arrowsize=arrow_size, ) plt.title(f\"{SPREAD_TITLE} from {self.start_node}\") plt.show() def draw_compare( self, figsize: Tuple[int, int] = (20, 8), node_size: int = 2000, node_color: str = \"lightblue\", edge_color: str = \"gray\", spread_cmap: plt.cm = plt.cm.summer, spread_arrow_size: int = 20, spread_alpha: float = 0.5, spread_arrow_style: str = \"-|>\", ) -> None: \"\"\" Draw the original graph and the spread graph side by side. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param node_color: Color of the nodes :param edge_color: Color of the edges :param spread_cmap: Colormap for coloring nodes based on their levels :param spread_arrow_size: Size of the arrows :param spread_alpha: Transparency of the nodes :param spread_arrow_style: Style of the arrows \"\"\" if not self.graph or not self.spread_graph: print(\"Error: Compares is not available. Load some data and run BFS first.\") return _, axes = plt.subplots(1, 2, figsize=figsize) pos = nx.spring_layout(self.graph) nx.draw_networkx_nodes( self.graph, pos, ax=axes[0], node_size=node_size, node_color=node_color ) nx.draw_networkx_labels(self.graph, pos, ax=axes[0]) nx.draw_networkx_edges(self.graph, pos, ax=axes[0], edge_color=edge_color, arrows=False) axes[0].set_title(CONNECTIONS_TITLE) pos = nx.spring_layout(self.spread_graph) node_colors = self.__calc_node_colors(spread_cmap) nx.draw_networkx_nodes( self.spread_graph, pos, ax=axes[1], node_size=node_size, alpha=spread_alpha, node_color=node_colors, ) nx.draw_networkx_labels(self.spread_graph, pos, ax=axes[1]) nx.draw_networkx_edges( self.spread_graph, pos, ax=axes[1], edge_color=edge_color, arrows=True, arrowstyle=spread_arrow_style, node_size=node_size, arrowsize=spread_arrow_size, ) axes[1].set_title(f\"{SPREAD_TITLE} from {self.start_node}\") plt.show()","title":"BfsCommunityGraph"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph.__bfs","text":"Perform BFS traversal starting from the given node. :return: List of nodes in BFS order Source code in src/models/bfs_community_graph.py def __bfs(self) -> List[str]: \"\"\" Perform BFS traversal starting from the given node. :return: List of nodes in BFS order \"\"\" self.spread_graph = nx.DiGraph() visited = set() queue = deque([(self.start_node, 0)]) bfs_order = [] visited.add(self.start_node) self.spread_graph.add_node(self.start_node) while queue: self.__print_log(f\"Queue: {queue}\") node, level = queue.popleft() self.__print_log(f\"Visiting {node} at level {level}\") bfs_order.append({node: level}) self.__print_log(f\"Neighbors of {node}: {list(self.graph.neighbors(node))}\") for neighbor in self.graph.neighbors(node): if neighbor not in visited: self.__print_log(f\"Adding {neighbor} to the queue\") next_level = level + 1 queue.append((neighbor, next_level)) self.bfs_deep = max(self.bfs_deep, next_level) visited.add(neighbor) self.spread_graph.add_node(neighbor) self.spread_graph.add_edge(node, neighbor) else: self.__print_log(f\"Skipping {neighbor}\") self.__print_log(f\"BFS end. Order: {bfs_order}\") self.bfs_order = bfs_order return bfs_order","title":"__bfs"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph.__calc_node_colors","text":"Return a colormap for coloring nodes based on their levels. :param cmap: Colormap object :return: Calculated colormap for coloring nodes Source code in src/models/bfs_community_graph.py def __calc_node_colors(self, cmap: plt.cm) -> plt.cm: \"\"\" Return a colormap for coloring nodes based on their levels. :param cmap: Colormap object :return: Calculated colormap for coloring nodes \"\"\" levels = [list(node.values())[0] for node in self.bfs_order] norm = plt.Normalize(levels[0], levels[-1]) return cmap(norm(levels))","title":"__calc_node_colors"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph.__clean_results","text":"Clean the results of the BFS algorithm. Source code in src/models/bfs_community_graph.py def __clean_results(self) -> None: \"\"\" Clean the results of the BFS algorithm. \"\"\" self.bfs_order = [] self.start_node = None self.spread_graph = None","title":"__clean_results"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph.__print_log","text":"Print log message if debug flag is set. :param message: Log message to print Source code in src/models/bfs_community_graph.py def __print_log(self, message: str) -> None: \"\"\" Print log message if debug flag is set. :param message: Log message to print \"\"\" if self.bfs_debug: print(message)","title":"__print_log"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph.__str__","text":"Return the string representation of the graph. :return: String representation of the graph Source code in src/models/bfs_community_graph.py def __str__(self) -> str: \"\"\" Return the string representation of the graph. :return: String representation of the graph \"\"\" gstr = ( f\"Graph Nodes: {self.graph.nodes() if self.graph else '-'}\\n\" f\"Graph Edges: {self.graph.edges() if self.graph else '-'}\\n\" f\"Deep: {self.bfs_deep}\\n\" f\"Spread order: {self.bfs_order}\\n\" f\"Start node: {self.start_node}\\n\" f\"Is Connected: {nx.is_connected(self.graph) if self.graph else '-'}\\n\" f\"Result graph nodes: {self.spread_graph.nodes() if self.spread_graph else '-'}\\n\" f\"Result graph edges: {self.spread_graph.edges() if self.spread_graph else '-'}\\n\" ) return gstr","title":"__str__"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph.draw_compare","text":"Draw the original graph and the spread graph side by side. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param node_color: Color of the nodes :param edge_color: Color of the edges :param spread_cmap: Colormap for coloring nodes based on their levels :param spread_arrow_size: Size of the arrows :param spread_alpha: Transparency of the nodes :param spread_arrow_style: Style of the arrows Source code in src/models/bfs_community_graph.py def draw_compare( self, figsize: Tuple[int, int] = (20, 8), node_size: int = 2000, node_color: str = \"lightblue\", edge_color: str = \"gray\", spread_cmap: plt.cm = plt.cm.summer, spread_arrow_size: int = 20, spread_alpha: float = 0.5, spread_arrow_style: str = \"-|>\", ) -> None: \"\"\" Draw the original graph and the spread graph side by side. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param node_color: Color of the nodes :param edge_color: Color of the edges :param spread_cmap: Colormap for coloring nodes based on their levels :param spread_arrow_size: Size of the arrows :param spread_alpha: Transparency of the nodes :param spread_arrow_style: Style of the arrows \"\"\" if not self.graph or not self.spread_graph: print(\"Error: Compares is not available. Load some data and run BFS first.\") return _, axes = plt.subplots(1, 2, figsize=figsize) pos = nx.spring_layout(self.graph) nx.draw_networkx_nodes( self.graph, pos, ax=axes[0], node_size=node_size, node_color=node_color ) nx.draw_networkx_labels(self.graph, pos, ax=axes[0]) nx.draw_networkx_edges(self.graph, pos, ax=axes[0], edge_color=edge_color, arrows=False) axes[0].set_title(CONNECTIONS_TITLE) pos = nx.spring_layout(self.spread_graph) node_colors = self.__calc_node_colors(spread_cmap) nx.draw_networkx_nodes( self.spread_graph, pos, ax=axes[1], node_size=node_size, alpha=spread_alpha, node_color=node_colors, ) nx.draw_networkx_labels(self.spread_graph, pos, ax=axes[1]) nx.draw_networkx_edges( self.spread_graph, pos, ax=axes[1], edge_color=edge_color, arrows=True, arrowstyle=spread_arrow_style, node_size=node_size, arrowsize=spread_arrow_size, ) axes[1].set_title(f\"{SPREAD_TITLE} from {self.start_node}\") plt.show()","title":"draw_compare"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph.draw_connections","text":"Draw the connections of the graph. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param node_color: Color of the nodes :param edge_color: Color of the edges Source code in src/models/bfs_community_graph.py def draw_connections( self, figsize: Tuple[int, int] = (10, 8), node_size: int = 2000, node_color: str = \"lightblue\", edge_color: str = \"gray\", ) -> None: \"\"\" Draw the connections of the graph. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param node_color: Color of the nodes :param edge_color: Color of the edges \"\"\" if not self.graph: print(\"Error: Graph is not set. Load some data first.\") return pos = nx.spring_layout(self.graph) plt.figure(figsize=figsize) nx.draw_networkx_nodes(self.graph, pos, node_size=node_size, node_color=node_color) nx.draw_networkx_labels(self.graph, pos) nx.draw_networkx_edges(self.graph, pos, edge_color=edge_color, arrows=False) plt.title(CONNECTIONS_TITLE) plt.show()","title":"draw_connections"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph.draw_spread","text":"Draw the spread of information from the start node. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param edge_color: Color of the edges :param cmap: Colormap for coloring nodes based on their levels :param alpha: Transparency of the nodes Source code in src/models/bfs_community_graph.py def draw_spread( self, figsize: Tuple[int, int] = (10, 8), node_size: int = 2000, edge_color: str = \"gray\", cmap: plt.cm = plt.cm.summer, alpha: float = 0.5, arrow_style: str = \"-|>\", arrow_size: int = 20, ) -> None: \"\"\" Draw the spread of information from the start node. :param figsize: Figure size for the plot :param node_size: Size of the nodes :param edge_color: Color of the edges :param cmap: Colormap for coloring nodes based on their levels :param alpha: Transparency of the nodes \"\"\" if not self.spread_graph: print(\"Error: Spread graph is not set. Use BfsCommunityGraph.run() method first.\") return plt.figure(figsize=figsize) pos = nx.spring_layout(self.spread_graph) node_colors = self.__calc_node_colors(cmap) nx.draw_networkx_nodes( self.spread_graph, pos, node_size=node_size, alpha=alpha, node_color=node_colors, ) nx.draw_networkx_labels( self.spread_graph, pos, ) nx.draw_networkx_edges( self.spread_graph, pos, edge_color=edge_color, arrows=True, arrowstyle=arrow_style, node_size=node_size, arrowsize=arrow_size, ) plt.title(f\"{SPREAD_TITLE} from {self.start_node}\") plt.show()","title":"draw_spread"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph.is_valid","text":"Check if the graph is valid for BFS algorithm. :return: True if the graph is valid, False otherwise Source code in src/models/bfs_community_graph.py def is_valid(self) -> bool: \"\"\" Check if the graph is valid for BFS algorithm. :return: True if the graph is valid, False otherwise \"\"\" valid = True if not self.graph: print(\"Error: Graph is not set.\") valid = False if valid and not isinstance(self.start_node, str): print(\"Error: Start node should be a string.\") valid = False if valid and not all(isinstance(node, str) for node in self.graph.nodes): print(\"Error: Nodes should be strings.\") valid = False if valid and self.start_node not in self.graph.nodes: print(\"Error: Start node is not in the graph.\") valid = False if not valid: print( \"Please resolve the above issues before analyzing information spread in social networks.\" ) return valid","title":"is_valid"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph.make_graph","text":"Create a graph from the given nodes and edges. :param nodes: List of nodes in the graph :param edges: List of edges in the graph Source code in src/models/bfs_community_graph.py def make_graph(self, nodes: List[str], edges: List[Tuple[str, str]]) -> None: \"\"\" Create a graph from the given nodes and edges. :param nodes: List of nodes in the graph :param edges: List of edges in the graph \"\"\" self.__clean_results() self.graph = nx.Graph() self.graph.add_nodes_from(nodes) self.graph.add_edges_from(edges)","title":"make_graph"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph.random_community","text":"Generate a random community graph with string nodes. :param num_nodes: Number of nodes in the graph :param edge_prob: Probability of an edge between nodes :param seed: Random seed for reproducibility Source code in src/models/bfs_community_graph.py def random_community(self, num_nodes: int, edge_prob: float, seed: int = None) -> None: \"\"\" Generate a random community graph with string nodes. :param num_nodes: Number of nodes in the graph :param edge_prob: Probability of an edge between nodes :param seed: Random seed for reproducibility \"\"\" self.__clean_results() self.graph = nx.erdos_renyi_graph(num_nodes, edge_prob, seed) labels = {i: f\"Person_{i}\" for i in range(num_nodes)} self.graph = nx.relabel_nodes(self.graph, labels)","title":"random_community"},{"location":"auto_bfs_community_graph/#src.models.bfs_community_graph.BfsCommunityGraph.run","text":"Run the BFS algorithm and return the results. :param start_node: The node to start the BFS traversal from :return: List of nodes in BFS order Source code in src/models/bfs_community_graph.py def run(self, start_node: str = None) -> List[Dict[str, int]]: \"\"\" Run the BFS algorithm and return the results. :param start_node: The node to start the BFS traversal from :return: List of nodes in BFS order \"\"\" if start_node: self.start_node = start_node else: self.start_node = list(self.graph.nodes)[0] if self.graph else None if not self.is_valid(): return {} self.__bfs() return self.bfs_order","title":"run"},{"location":"auto_test_vfs_community_graph/","text":"Automatically generated with mkdocstrings tests.test_bfs_community_graph.TestBfsCommunityGraph Bases: TestCase Source code in tests/test_bfs_community_graph.py class TestBfsCommunityGraph(unittest.TestCase): def setUp(self) -> None: self.graph = BfsCommunityGraph() def test_result(self): \"\"\" Test the result of the BFS algorithm \"\"\" print(\"Testing result...\") people = [ \"Patryk\", \"Kasia\", \"Kajetan\", \"Ania\", \"Artur\", \"Karolina\", \"Tomek\", \"Klaudia\", \"Krzysiek\", \"Asia\", ] connections = [ (\"Patryk\", \"Kasia\"), (\"Patryk\", \"Kajetan\"), (\"Patryk\", \"Ania\"), (\"Patryk\", \"Artur\"), (\"Kasia\", \"Karolina\"), (\"Kasia\", \"Tomek\"), (\"Kajetan\", \"Klaudia\"), (\"Kajetan\", \"Krzysiek\"), (\"Ania\", \"Asia\"), (\"Ania\", \"Krzysiek\"), (\"Artur\", \"Karolina\"), (\"Artur\", \"Tomek\"), (\"Karolina\", \"Klaudia\"), (\"Klaudia\", \"Krzysiek\"), (\"Krzysiek\", \"Asia\"), ] self.graph.make_graph(people, connections) self.graph.run() self.assertEqual(self.graph.graph.number_of_nodes(), 10) self.assertEqual(self.graph.graph.number_of_edges(), 15) self.assertEqual(self.graph.spread_graph.number_of_nodes(), 10) self.assertEqual(self.graph.spread_graph.number_of_edges(), 9) self.assertEqual(self.graph.spread_graph.degree(\"Patryk\"), 4) def test_no_params(self): \"\"\" Test if the graph is invalid when no parameters are passed \"\"\" print(\"Testing no params...\") self.assertFalse(self.graph.is_valid()) self.assertEqual(self.graph.run(), {}) def test_invalid_params(self): \"\"\" Test if the graph is invalid when invalid parameters are passed \"\"\" print(\"Testing invalid params...\") non_string_nodes = [1, 2, \"3\", 4] non_string_edges = [(1, 2), (2, \"3\"), (\"3\", 4)] self.graph.make_graph(non_string_nodes, non_string_edges) self.assertFalse(self.graph.is_valid()) self.assertEqual(self.graph.run(), {}) def test_invalid_start_node(self): \"\"\" Test if the graph is invalid when invalid parameters are passed \"\"\" print(\"Testing invalid start node...\") nodes = [\"1\", \"2\", \"3\", \"4\"] edges = [(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\")] self.graph.make_graph(nodes, edges) self.graph.start_node = \"5\" self.assertFalse(self.graph.is_valid()) self.assertEqual(self.graph.run(\"5\"), {}) def test_make_graph_from_edges(self): \"\"\" Test graph creation from a list of edges \"\"\" print(\"Testing make graph from edges...\") edges = [(\"Person_1\", \"Person_2\"), (\"Person_2\", \"Person_3\"), (\"Person_3\", \"Person_4\")] self.graph.make_graph([], edges) self.assertEqual(self.graph.graph.number_of_nodes(), 4) # There should be 4 unique nodes self.assertEqual(self.graph.graph.number_of_edges(), 3) # There should be 3 edges def test_graph_string_representation(self): \"\"\" Check if the string representation includes correct information \"\"\" print(\"Testing graph string representation...\") edges = [(\"Person_1\", \"Person_2\"), (\"Person_2\", \"Person_3\")] self.graph.make_graph([], edges) self.graph.start_node = \"Person_1\" graph_str = str(self.graph) self.assertIn(\"Graph Nodes\", graph_str) self.assertIn(\"Graph Edges\", graph_str) self.assertIn(\"Deep\", graph_str) self.assertIn(\"Spread order\", graph_str) self.assertIn(\"Start node\", graph_str) def test_random_community(self): \"\"\" Test the random community graph generation \"\"\" print(\"Testing random community...\") # Generate a random community graph and check if it has the correct number of nodes num_nodes = 5 edge_prob = 0.4 self.graph.random_community(num_nodes, edge_prob) # Check if the generated graph has the specified number of nodes self.assertEqual(len(self.graph.graph.nodes), num_nodes) # Check if all nodes are labeled as strings (e.g., \"Person_0\", \"Person_1\", ...) all_labels_are_strings = all( isinstance(node, str) and node.startswith(\"Person_\") for node in self.graph.graph.nodes ) self.assertTrue(all_labels_are_strings) test_graph_string_representation() Check if the string representation includes correct information Source code in tests/test_bfs_community_graph.py def test_graph_string_representation(self): \"\"\" Check if the string representation includes correct information \"\"\" print(\"Testing graph string representation...\") edges = [(\"Person_1\", \"Person_2\"), (\"Person_2\", \"Person_3\")] self.graph.make_graph([], edges) self.graph.start_node = \"Person_1\" graph_str = str(self.graph) self.assertIn(\"Graph Nodes\", graph_str) self.assertIn(\"Graph Edges\", graph_str) self.assertIn(\"Deep\", graph_str) self.assertIn(\"Spread order\", graph_str) self.assertIn(\"Start node\", graph_str) test_invalid_params() Test if the graph is invalid when invalid parameters are passed Source code in tests/test_bfs_community_graph.py def test_invalid_params(self): \"\"\" Test if the graph is invalid when invalid parameters are passed \"\"\" print(\"Testing invalid params...\") non_string_nodes = [1, 2, \"3\", 4] non_string_edges = [(1, 2), (2, \"3\"), (\"3\", 4)] self.graph.make_graph(non_string_nodes, non_string_edges) self.assertFalse(self.graph.is_valid()) self.assertEqual(self.graph.run(), {}) test_invalid_start_node() Test if the graph is invalid when invalid parameters are passed Source code in tests/test_bfs_community_graph.py def test_invalid_start_node(self): \"\"\" Test if the graph is invalid when invalid parameters are passed \"\"\" print(\"Testing invalid start node...\") nodes = [\"1\", \"2\", \"3\", \"4\"] edges = [(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\")] self.graph.make_graph(nodes, edges) self.graph.start_node = \"5\" self.assertFalse(self.graph.is_valid()) self.assertEqual(self.graph.run(\"5\"), {}) test_make_graph_from_edges() Test graph creation from a list of edges Source code in tests/test_bfs_community_graph.py def test_make_graph_from_edges(self): \"\"\" Test graph creation from a list of edges \"\"\" print(\"Testing make graph from edges...\") edges = [(\"Person_1\", \"Person_2\"), (\"Person_2\", \"Person_3\"), (\"Person_3\", \"Person_4\")] self.graph.make_graph([], edges) self.assertEqual(self.graph.graph.number_of_nodes(), 4) # There should be 4 unique nodes self.assertEqual(self.graph.graph.number_of_edges(), 3) # There should be 3 edges test_no_params() Test if the graph is invalid when no parameters are passed Source code in tests/test_bfs_community_graph.py def test_no_params(self): \"\"\" Test if the graph is invalid when no parameters are passed \"\"\" print(\"Testing no params...\") self.assertFalse(self.graph.is_valid()) self.assertEqual(self.graph.run(), {}) test_random_community() Test the random community graph generation Source code in tests/test_bfs_community_graph.py def test_random_community(self): \"\"\" Test the random community graph generation \"\"\" print(\"Testing random community...\") # Generate a random community graph and check if it has the correct number of nodes num_nodes = 5 edge_prob = 0.4 self.graph.random_community(num_nodes, edge_prob) # Check if the generated graph has the specified number of nodes self.assertEqual(len(self.graph.graph.nodes), num_nodes) # Check if all nodes are labeled as strings (e.g., \"Person_0\", \"Person_1\", ...) all_labels_are_strings = all( isinstance(node, str) and node.startswith(\"Person_\") for node in self.graph.graph.nodes ) self.assertTrue(all_labels_are_strings) test_result() Test the result of the BFS algorithm Source code in tests/test_bfs_community_graph.py def test_result(self): \"\"\" Test the result of the BFS algorithm \"\"\" print(\"Testing result...\") people = [ \"Patryk\", \"Kasia\", \"Kajetan\", \"Ania\", \"Artur\", \"Karolina\", \"Tomek\", \"Klaudia\", \"Krzysiek\", \"Asia\", ] connections = [ (\"Patryk\", \"Kasia\"), (\"Patryk\", \"Kajetan\"), (\"Patryk\", \"Ania\"), (\"Patryk\", \"Artur\"), (\"Kasia\", \"Karolina\"), (\"Kasia\", \"Tomek\"), (\"Kajetan\", \"Klaudia\"), (\"Kajetan\", \"Krzysiek\"), (\"Ania\", \"Asia\"), (\"Ania\", \"Krzysiek\"), (\"Artur\", \"Karolina\"), (\"Artur\", \"Tomek\"), (\"Karolina\", \"Klaudia\"), (\"Klaudia\", \"Krzysiek\"), (\"Krzysiek\", \"Asia\"), ] self.graph.make_graph(people, connections) self.graph.run() self.assertEqual(self.graph.graph.number_of_nodes(), 10) self.assertEqual(self.graph.graph.number_of_edges(), 15) self.assertEqual(self.graph.spread_graph.number_of_nodes(), 10) self.assertEqual(self.graph.spread_graph.number_of_edges(), 9) self.assertEqual(self.graph.spread_graph.degree(\"Patryk\"), 4)","title":"DocString (Tests)"},{"location":"auto_test_vfs_community_graph/#tests.test_bfs_community_graph.TestBfsCommunityGraph","text":"Bases: TestCase Source code in tests/test_bfs_community_graph.py class TestBfsCommunityGraph(unittest.TestCase): def setUp(self) -> None: self.graph = BfsCommunityGraph() def test_result(self): \"\"\" Test the result of the BFS algorithm \"\"\" print(\"Testing result...\") people = [ \"Patryk\", \"Kasia\", \"Kajetan\", \"Ania\", \"Artur\", \"Karolina\", \"Tomek\", \"Klaudia\", \"Krzysiek\", \"Asia\", ] connections = [ (\"Patryk\", \"Kasia\"), (\"Patryk\", \"Kajetan\"), (\"Patryk\", \"Ania\"), (\"Patryk\", \"Artur\"), (\"Kasia\", \"Karolina\"), (\"Kasia\", \"Tomek\"), (\"Kajetan\", \"Klaudia\"), (\"Kajetan\", \"Krzysiek\"), (\"Ania\", \"Asia\"), (\"Ania\", \"Krzysiek\"), (\"Artur\", \"Karolina\"), (\"Artur\", \"Tomek\"), (\"Karolina\", \"Klaudia\"), (\"Klaudia\", \"Krzysiek\"), (\"Krzysiek\", \"Asia\"), ] self.graph.make_graph(people, connections) self.graph.run() self.assertEqual(self.graph.graph.number_of_nodes(), 10) self.assertEqual(self.graph.graph.number_of_edges(), 15) self.assertEqual(self.graph.spread_graph.number_of_nodes(), 10) self.assertEqual(self.graph.spread_graph.number_of_edges(), 9) self.assertEqual(self.graph.spread_graph.degree(\"Patryk\"), 4) def test_no_params(self): \"\"\" Test if the graph is invalid when no parameters are passed \"\"\" print(\"Testing no params...\") self.assertFalse(self.graph.is_valid()) self.assertEqual(self.graph.run(), {}) def test_invalid_params(self): \"\"\" Test if the graph is invalid when invalid parameters are passed \"\"\" print(\"Testing invalid params...\") non_string_nodes = [1, 2, \"3\", 4] non_string_edges = [(1, 2), (2, \"3\"), (\"3\", 4)] self.graph.make_graph(non_string_nodes, non_string_edges) self.assertFalse(self.graph.is_valid()) self.assertEqual(self.graph.run(), {}) def test_invalid_start_node(self): \"\"\" Test if the graph is invalid when invalid parameters are passed \"\"\" print(\"Testing invalid start node...\") nodes = [\"1\", \"2\", \"3\", \"4\"] edges = [(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\")] self.graph.make_graph(nodes, edges) self.graph.start_node = \"5\" self.assertFalse(self.graph.is_valid()) self.assertEqual(self.graph.run(\"5\"), {}) def test_make_graph_from_edges(self): \"\"\" Test graph creation from a list of edges \"\"\" print(\"Testing make graph from edges...\") edges = [(\"Person_1\", \"Person_2\"), (\"Person_2\", \"Person_3\"), (\"Person_3\", \"Person_4\")] self.graph.make_graph([], edges) self.assertEqual(self.graph.graph.number_of_nodes(), 4) # There should be 4 unique nodes self.assertEqual(self.graph.graph.number_of_edges(), 3) # There should be 3 edges def test_graph_string_representation(self): \"\"\" Check if the string representation includes correct information \"\"\" print(\"Testing graph string representation...\") edges = [(\"Person_1\", \"Person_2\"), (\"Person_2\", \"Person_3\")] self.graph.make_graph([], edges) self.graph.start_node = \"Person_1\" graph_str = str(self.graph) self.assertIn(\"Graph Nodes\", graph_str) self.assertIn(\"Graph Edges\", graph_str) self.assertIn(\"Deep\", graph_str) self.assertIn(\"Spread order\", graph_str) self.assertIn(\"Start node\", graph_str) def test_random_community(self): \"\"\" Test the random community graph generation \"\"\" print(\"Testing random community...\") # Generate a random community graph and check if it has the correct number of nodes num_nodes = 5 edge_prob = 0.4 self.graph.random_community(num_nodes, edge_prob) # Check if the generated graph has the specified number of nodes self.assertEqual(len(self.graph.graph.nodes), num_nodes) # Check if all nodes are labeled as strings (e.g., \"Person_0\", \"Person_1\", ...) all_labels_are_strings = all( isinstance(node, str) and node.startswith(\"Person_\") for node in self.graph.graph.nodes ) self.assertTrue(all_labels_are_strings)","title":"TestBfsCommunityGraph"},{"location":"auto_test_vfs_community_graph/#tests.test_bfs_community_graph.TestBfsCommunityGraph.test_graph_string_representation","text":"Check if the string representation includes correct information Source code in tests/test_bfs_community_graph.py def test_graph_string_representation(self): \"\"\" Check if the string representation includes correct information \"\"\" print(\"Testing graph string representation...\") edges = [(\"Person_1\", \"Person_2\"), (\"Person_2\", \"Person_3\")] self.graph.make_graph([], edges) self.graph.start_node = \"Person_1\" graph_str = str(self.graph) self.assertIn(\"Graph Nodes\", graph_str) self.assertIn(\"Graph Edges\", graph_str) self.assertIn(\"Deep\", graph_str) self.assertIn(\"Spread order\", graph_str) self.assertIn(\"Start node\", graph_str)","title":"test_graph_string_representation"},{"location":"auto_test_vfs_community_graph/#tests.test_bfs_community_graph.TestBfsCommunityGraph.test_invalid_params","text":"Test if the graph is invalid when invalid parameters are passed Source code in tests/test_bfs_community_graph.py def test_invalid_params(self): \"\"\" Test if the graph is invalid when invalid parameters are passed \"\"\" print(\"Testing invalid params...\") non_string_nodes = [1, 2, \"3\", 4] non_string_edges = [(1, 2), (2, \"3\"), (\"3\", 4)] self.graph.make_graph(non_string_nodes, non_string_edges) self.assertFalse(self.graph.is_valid()) self.assertEqual(self.graph.run(), {})","title":"test_invalid_params"},{"location":"auto_test_vfs_community_graph/#tests.test_bfs_community_graph.TestBfsCommunityGraph.test_invalid_start_node","text":"Test if the graph is invalid when invalid parameters are passed Source code in tests/test_bfs_community_graph.py def test_invalid_start_node(self): \"\"\" Test if the graph is invalid when invalid parameters are passed \"\"\" print(\"Testing invalid start node...\") nodes = [\"1\", \"2\", \"3\", \"4\"] edges = [(\"1\", \"2\"), (\"2\", \"3\"), (\"3\", \"4\")] self.graph.make_graph(nodes, edges) self.graph.start_node = \"5\" self.assertFalse(self.graph.is_valid()) self.assertEqual(self.graph.run(\"5\"), {})","title":"test_invalid_start_node"},{"location":"auto_test_vfs_community_graph/#tests.test_bfs_community_graph.TestBfsCommunityGraph.test_make_graph_from_edges","text":"Test graph creation from a list of edges Source code in tests/test_bfs_community_graph.py def test_make_graph_from_edges(self): \"\"\" Test graph creation from a list of edges \"\"\" print(\"Testing make graph from edges...\") edges = [(\"Person_1\", \"Person_2\"), (\"Person_2\", \"Person_3\"), (\"Person_3\", \"Person_4\")] self.graph.make_graph([], edges) self.assertEqual(self.graph.graph.number_of_nodes(), 4) # There should be 4 unique nodes self.assertEqual(self.graph.graph.number_of_edges(), 3) # There should be 3 edges","title":"test_make_graph_from_edges"},{"location":"auto_test_vfs_community_graph/#tests.test_bfs_community_graph.TestBfsCommunityGraph.test_no_params","text":"Test if the graph is invalid when no parameters are passed Source code in tests/test_bfs_community_graph.py def test_no_params(self): \"\"\" Test if the graph is invalid when no parameters are passed \"\"\" print(\"Testing no params...\") self.assertFalse(self.graph.is_valid()) self.assertEqual(self.graph.run(), {})","title":"test_no_params"},{"location":"auto_test_vfs_community_graph/#tests.test_bfs_community_graph.TestBfsCommunityGraph.test_random_community","text":"Test the random community graph generation Source code in tests/test_bfs_community_graph.py def test_random_community(self): \"\"\" Test the random community graph generation \"\"\" print(\"Testing random community...\") # Generate a random community graph and check if it has the correct number of nodes num_nodes = 5 edge_prob = 0.4 self.graph.random_community(num_nodes, edge_prob) # Check if the generated graph has the specified number of nodes self.assertEqual(len(self.graph.graph.nodes), num_nodes) # Check if all nodes are labeled as strings (e.g., \"Person_0\", \"Person_1\", ...) all_labels_are_strings = all( isinstance(node, str) and node.startswith(\"Person_\") for node in self.graph.graph.nodes ) self.assertTrue(all_labels_are_strings)","title":"test_random_community"},{"location":"auto_test_vfs_community_graph/#tests.test_bfs_community_graph.TestBfsCommunityGraph.test_result","text":"Test the result of the BFS algorithm Source code in tests/test_bfs_community_graph.py def test_result(self): \"\"\" Test the result of the BFS algorithm \"\"\" print(\"Testing result...\") people = [ \"Patryk\", \"Kasia\", \"Kajetan\", \"Ania\", \"Artur\", \"Karolina\", \"Tomek\", \"Klaudia\", \"Krzysiek\", \"Asia\", ] connections = [ (\"Patryk\", \"Kasia\"), (\"Patryk\", \"Kajetan\"), (\"Patryk\", \"Ania\"), (\"Patryk\", \"Artur\"), (\"Kasia\", \"Karolina\"), (\"Kasia\", \"Tomek\"), (\"Kajetan\", \"Klaudia\"), (\"Kajetan\", \"Krzysiek\"), (\"Ania\", \"Asia\"), (\"Ania\", \"Krzysiek\"), (\"Artur\", \"Karolina\"), (\"Artur\", \"Tomek\"), (\"Karolina\", \"Klaudia\"), (\"Klaudia\", \"Krzysiek\"), (\"Krzysiek\", \"Asia\"), ] self.graph.make_graph(people, connections) self.graph.run() self.assertEqual(self.graph.graph.number_of_nodes(), 10) self.assertEqual(self.graph.graph.number_of_edges(), 15) self.assertEqual(self.graph.spread_graph.number_of_nodes(), 10) self.assertEqual(self.graph.spread_graph.number_of_edges(), 9) self.assertEqual(self.graph.spread_graph.degree(\"Patryk\"), 4)","title":"test_result"},{"location":"bfs_community_graph/","text":"BFS Community Graph This class provides functionality to create, analyze, and visualize how information spreads through social network. Usage from bfs_community_graph import BfsCommunityGraph # Create a new instance graph = BfsCommunityGraph() # Generate a random community graph.random_community(num_nodes=5, edge_prob=0.4) # Run BFS analysis starting from \"Person_0\" results = graph.run(start_node=\"Person_0\") # Visualize the results graph.draw_compare() Class Overview BfsCommunityGraph BfsCommunityGraph(graph: Graph = None, start_node: str = None, debug: bool = False) Main class for social network analysis using BFS algorithm. Parameters graph (networkx.Graph, optional): Initial graph representing the social network start_node (str, optional): Starting node for BFS traversal debug (bool, optional): Enable debug logging during BFS algorithm execution Methods run def run(start_node: str = None) -> List[Dict[str, int]] Executes the BFS algorithm on the graph. Parameters start_node (str, optional): Node to start the BFS traversal from Returns List of dictionaries containing nodes and their levels in BFS order make_graph def make_graph(nodes: List[str], edges: List[Tuple[str, str]]) -> None Creates a graph from given nodes and edges. Parameters nodes : List of node names edges : List of edge tuples (source, target) random_community def random_community(num_nodes: int, edge_prob: float, seed: int = None) -> None Generates a random community graph. Parameters num_nodes : Number of nodes to generate edge_prob : Probability of edge creation between nodes seed (optional): Random seed for reproducibility Visualization Methods draw_connections def draw_connections( figsize: Tuple[int, int] = (10, 8), node_size: int = 2000, node_color: str = \"lightblue\", edge_color: str = \"gray\" ) -> None Visualizes the social network connections. draw_spread def draw_spread( figsize: Tuple[int, int] = (10, 8), node_size: int = 2000, edge_color: str = \"gray\", cmap: plt.cm = plt.cm.summer, alpha: float = 0.5, arrow_style: str = \"-|>\", arrow_size: int = 20 ) -> None Visualizes the information spread pattern. draw_compare def draw_compare( figsize: Tuple[int, int] = (20, 8), node_size: int = 2000, node_color: str = \"lightblue\", edge_color: str = \"gray\", spread_cmap: plt.cm = plt.cm.summer, spread_arrow_size: int = 20, spread_alpha: float = 0.5, spread_arrow_style: str = \"-|>\" ) -> None Displays both the original network and spread pattern side by side. Examples Creating a Custom Network # Create a new graph instance graph = BfsCommunityGraph() # Define nodes and edges nodes = [ \"Patryk\", \"Kasia\", \"Kajetan\", \"Ania\", \"Artur\", \"Karolina\", \"Tomek\", \"Klaudia\", \"Krzysiek\", \"Asia\", ] edges = [ (\"Patryk\", \"Kasia\"), (\"Patryk\", \"Kajetan\"), (\"Patryk\", \"Ania\"), (\"Patryk\", \"Artur\"), (\"Kasia\", \"Karolina\"), (\"Kasia\", \"Tomek\"), (\"Kajetan\", \"Klaudia\"), (\"Kajetan\", \"Krzysiek\"), (\"Ania\", \"Asia\"), (\"Ania\", \"Krzysiek\"), (\"Artur\", \"Karolina\"), (\"Artur\", \"Tomek\"), (\"Karolina\", \"Klaudia\"), (\"Klaudia\", \"Krzysiek\"), (\"Krzysiek\", \"Asia\"), ] # Create the graph graph.make_graph(nodes, edges) # Run analysis starting from Patryk results = graph.run(\"Patryk\") # Visualize the results graph.draw_compare() Analyzing a Random Community # Create and analyze a random community graph = BfsCommunityGraph() graph.random_community(num_nodes=5, edge_prob=0.4, seed=42) results = graph.run(\"Person_0\") # Show the spread visualization graph.draw_spread() Notes The class uses NetworkX for graph operations and Matplotlib for visualization Node names should be strings It is recommended to ensure that the graph is connected for proper BFS traversal","title":"BFS Community Graph"},{"location":"bfs_community_graph/#bfs-community-graph","text":"This class provides functionality to create, analyze, and visualize how information spreads through social network.","title":"BFS Community Graph"},{"location":"bfs_community_graph/#usage","text":"from bfs_community_graph import BfsCommunityGraph # Create a new instance graph = BfsCommunityGraph() # Generate a random community graph.random_community(num_nodes=5, edge_prob=0.4) # Run BFS analysis starting from \"Person_0\" results = graph.run(start_node=\"Person_0\") # Visualize the results graph.draw_compare()","title":"Usage"},{"location":"bfs_community_graph/#class-overview","text":"","title":"Class Overview"},{"location":"bfs_community_graph/#bfscommunitygraph","text":"BfsCommunityGraph(graph: Graph = None, start_node: str = None, debug: bool = False) Main class for social network analysis using BFS algorithm.","title":"BfsCommunityGraph"},{"location":"bfs_community_graph/#parameters","text":"graph (networkx.Graph, optional): Initial graph representing the social network start_node (str, optional): Starting node for BFS traversal debug (bool, optional): Enable debug logging during BFS algorithm execution","title":"Parameters"},{"location":"bfs_community_graph/#methods","text":"","title":"Methods"},{"location":"bfs_community_graph/#run","text":"def run(start_node: str = None) -> List[Dict[str, int]] Executes the BFS algorithm on the graph.","title":"run"},{"location":"bfs_community_graph/#parameters_1","text":"start_node (str, optional): Node to start the BFS traversal from","title":"Parameters"},{"location":"bfs_community_graph/#returns","text":"List of dictionaries containing nodes and their levels in BFS order","title":"Returns"},{"location":"bfs_community_graph/#make_graph","text":"def make_graph(nodes: List[str], edges: List[Tuple[str, str]]) -> None Creates a graph from given nodes and edges.","title":"make_graph"},{"location":"bfs_community_graph/#parameters_2","text":"nodes : List of node names edges : List of edge tuples (source, target)","title":"Parameters"},{"location":"bfs_community_graph/#random_community","text":"def random_community(num_nodes: int, edge_prob: float, seed: int = None) -> None Generates a random community graph.","title":"random_community"},{"location":"bfs_community_graph/#parameters_3","text":"num_nodes : Number of nodes to generate edge_prob : Probability of edge creation between nodes seed (optional): Random seed for reproducibility","title":"Parameters"},{"location":"bfs_community_graph/#visualization-methods","text":"","title":"Visualization Methods"},{"location":"bfs_community_graph/#draw_connections","text":"def draw_connections( figsize: Tuple[int, int] = (10, 8), node_size: int = 2000, node_color: str = \"lightblue\", edge_color: str = \"gray\" ) -> None Visualizes the social network connections.","title":"draw_connections"},{"location":"bfs_community_graph/#draw_spread","text":"def draw_spread( figsize: Tuple[int, int] = (10, 8), node_size: int = 2000, edge_color: str = \"gray\", cmap: plt.cm = plt.cm.summer, alpha: float = 0.5, arrow_style: str = \"-|>\", arrow_size: int = 20 ) -> None Visualizes the information spread pattern.","title":"draw_spread"},{"location":"bfs_community_graph/#draw_compare","text":"def draw_compare( figsize: Tuple[int, int] = (20, 8), node_size: int = 2000, node_color: str = \"lightblue\", edge_color: str = \"gray\", spread_cmap: plt.cm = plt.cm.summer, spread_arrow_size: int = 20, spread_alpha: float = 0.5, spread_arrow_style: str = \"-|>\" ) -> None Displays both the original network and spread pattern side by side.","title":"draw_compare"},{"location":"bfs_community_graph/#examples","text":"","title":"Examples"},{"location":"bfs_community_graph/#creating-a-custom-network","text":"# Create a new graph instance graph = BfsCommunityGraph() # Define nodes and edges nodes = [ \"Patryk\", \"Kasia\", \"Kajetan\", \"Ania\", \"Artur\", \"Karolina\", \"Tomek\", \"Klaudia\", \"Krzysiek\", \"Asia\", ] edges = [ (\"Patryk\", \"Kasia\"), (\"Patryk\", \"Kajetan\"), (\"Patryk\", \"Ania\"), (\"Patryk\", \"Artur\"), (\"Kasia\", \"Karolina\"), (\"Kasia\", \"Tomek\"), (\"Kajetan\", \"Klaudia\"), (\"Kajetan\", \"Krzysiek\"), (\"Ania\", \"Asia\"), (\"Ania\", \"Krzysiek\"), (\"Artur\", \"Karolina\"), (\"Artur\", \"Tomek\"), (\"Karolina\", \"Klaudia\"), (\"Klaudia\", \"Krzysiek\"), (\"Krzysiek\", \"Asia\"), ] # Create the graph graph.make_graph(nodes, edges) # Run analysis starting from Patryk results = graph.run(\"Patryk\") # Visualize the results graph.draw_compare()","title":"Creating a Custom Network"},{"location":"bfs_community_graph/#analyzing-a-random-community","text":"# Create and analyze a random community graph = BfsCommunityGraph() graph.random_community(num_nodes=5, edge_prob=0.4, seed=42) results = graph.run(\"Person_0\") # Show the spread visualization graph.draw_spread()","title":"Analyzing a Random Community"},{"location":"bfs_community_graph/#notes","text":"The class uses NetworkX for graph operations and Matplotlib for visualization Node names should be strings It is recommended to ensure that the graph is connected for proper BFS traversal","title":"Notes"}]}